/**
 * CAD File Parser Utility
 * Parses SVG, DXF, DWF, and CAD Script files to extract ramp design data
 */

class CADFileParser {
    constructor() {
        this.parsedData = null;
    }

    /**
     * Main entry point - determines file type and routes to appropriate parser
     * @param {File} file - The file object from file input
     * @returns {Promise<Object>} Parsed data object
     */
    async parseFile(file) {
        const fileName = file.name.toLowerCase();
        const fileExtension = fileName.split('.').pop();

        try {
            const fileContent = await this.readFileContent(file);

            switch (fileExtension) {
                case 'svg':
                    return await this.parseSVG(fileContent);
                case 'dxf':
                    return await this.parseDXF(fileContent);
                case 'dwf':
                    return await this.parseDWF(file);
                case 'scr':
                    return await this.parseCADScript(fileContent);
                default:
                    // Try to detect file type by content
                    if (fileContent.trim().startsWith('<')) {
                        return await this.parseSVG(fileContent);
                    } else if (fileContent.includes('0\nSECTION') || fileContent.includes('ENTITIES')) {
                        return await this.parseDXF(fileContent);
                    }
                    throw new Error(`Unsupported file type: ${fileExtension}`);
            }
        } catch (error) {
            console.error('Parse error:', error);
            throw new Error(`Failed to parse file: ${error.message}`);
        }
    }

    /**
     * Read file content as text
     */
    readFileContent(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (e) => reject(new Error('Failed to read file'));
            reader.readAsText(file);
        });
    }

    /**
     * Parse SVG file generated by the ramp drawer tool
     */
    async parseSVG(svgContent) {
        const parser = new DOMParser();
        const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');

        const data = {
            width: null,
            startingRL: null,
            startingChainage: null,
            startLabel: null,
            endLabel: null,
            chainagePrefix: 'CH',
            segments: [],
            distanceUnits: 'm',
            chainagePosition: 'prefix',
            sectionSubtitle: '',
            planSubtitle: ''
        };

        // Check for parse errors
        const parserError = svgDoc.querySelector('parsererror');
        if (parserError) {
            throw new Error('Invalid SVG file');
        }

        // Look for metadata in SVG comments or data attributes
        const comments = this.extractSVGComments(svgContent);
        const metadata = this.extractMetadataFromComments(comments);

        if (metadata) {
            Object.assign(data, metadata);
        }

        // Extract text elements that might contain design parameters
        const textElements = svgDoc.querySelectorAll('text');
        const textContent = [];

        textElements.forEach(text => {
            const content = text.textContent.trim();
            if (content) {
                textContent.push(content);
            }
        });

        // Try to extract ramp width from text
        const widthMatch = textContent.find(t => t.toLowerCase().includes('width'));
        if (widthMatch) {
            const widthValue = this.extractNumber(widthMatch);
            if (widthValue !== null) {
                data.width = widthValue;
            }
        }

        // Extract chainage and RL values
        const chainageValues = [];
        const rlValues = [];

        textContent.forEach(text => {
            // Extract chainage values (CH, CL, ST, etc.)
            if (text.match(/^(CH|CL|ST)\s*\d+\.?\d*/i) || text.match(/\d+\.?\d*\s*(m|mm)\s*(CH|CL|ST)/i)) {
                const value = this.extractNumber(text);
                if (value !== null) {
                    chainageValues.push(value);
                    // Extract prefix if present
                    const prefixMatch = text.match(/^([A-Z]+)/);
                    if (prefixMatch) {
                        data.chainagePrefix = prefixMatch[1];
                    }
                }
            }

            // Extract RL values
            if (text.match(/RL\s*[:\-]?\s*\d+\.?\d*/i) || text.match(/^\d+\.?\d+$/)) {
                const value = this.extractNumber(text);
                if (value !== null && !chainageValues.includes(value)) {
                    rlValues.push(value);
                }
            }

            // Extract grade values
            if (text.match(/\d+\.?\d*%/) || text.match(/1:\d+\.?\d*/)) {
                // Grade information found
            }
        });

        // Set starting values if found
        if (chainageValues.length > 0) {
            data.startingChainage = Math.min(...chainageValues);
        }

        if (rlValues.length > 0) {
            data.startingRL = Math.min(...rlValues);
        }

        // Try to detect units
        const unitsMatch = textContent.find(t => t.includes('mm') || t.includes('millimetre'));
        if (unitsMatch) {
            data.distanceUnits = 'mm';
        }

        // Extract labels from text near edges
        const labels = textContent.filter(t =>
            t.length > 2 &&
            !t.match(/^[\d\.\s]+$/) &&
            !t.match(/^(CH|CL|ST|RL)/i) &&
            !t.includes('%') &&
            !t.includes(':')
        );

        if (labels.length >= 2) {
            data.startLabel = labels[0];
            data.endLabel = labels[1];
        }

        return data;
    }

    /**
     * Parse DXF (Drawing Exchange Format) file
     */
    async parseDXF(dxfContent) {
        const data = {
            width: null,
            startingRL: null,
            startingChainage: null,
            startLabel: null,
            endLabel: null,
            chainagePrefix: 'CH',
            segments: [],
            distanceUnits: 'm'
        };

        const lines = dxfContent.split('\n').map(l => l.trim());

        // Parse DXF entities
        let inEntitiesSection = false;
        let currentEntity = null;
        let entityData = {};

        for (let i = 0; i < lines.length; i++) {
            const code = lines[i];
            const value = lines[i + 1];

            if (code === '0' && value === 'SECTION') {
                continue;
            }

            if (code === '2' && value === 'ENTITIES') {
                inEntitiesSection = true;
                continue;
            }

            if (code === '0' && value === 'ENDSEC') {
                inEntitiesSection = false;
                continue;
            }

            if (!inEntitiesSection) continue;

            // Start of new entity
            if (code === '0') {
                if (currentEntity && Object.keys(entityData).length > 0) {
                    this.processDXFEntity(currentEntity, entityData, data);
                }
                currentEntity = value;
                entityData = { type: value };
                continue;
            }

            // Store entity data
            entityData[code] = value;
        }

        // Process last entity
        if (currentEntity && Object.keys(entityData).length > 0) {
            this.processDXFEntity(currentEntity, entityData, data);
        }

        return data;
    }

    /**
     * Process individual DXF entity
     */
    processDXFEntity(entityType, entityData, data) {
        switch (entityType) {
            case 'LINE':
            case 'POLYLINE':
            case 'LWPOLYLINE':
                // Extract geometric data
                const x1 = parseFloat(entityData['10']);
                const y1 = parseFloat(entityData['20']);
                const x2 = parseFloat(entityData['11']);
                const y2 = parseFloat(entityData['21']);

                if (!isNaN(x1) && !isNaN(y1)) {
                    // Calculate segment length if we have both points
                    if (!isNaN(x2) && !isNaN(y2)) {
                        const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                        const rise = y2 - y1;
                        const grade = length > 0 ? (rise / length) * 100 : 0;

                        data.segments.push({
                            length: length,
                            grade: grade
                        });
                    }
                }
                break;

            case 'TEXT':
            case 'MTEXT':
                // Extract text values
                const text = entityData['1'] || entityData['3'];
                if (text) {
                    // Try to extract parameters from text
                    if (text.toLowerCase().includes('width')) {
                        const width = this.extractNumber(text);
                        if (width !== null) data.width = width;
                    }

                    if (text.match(/^(CH|CL|ST)/i)) {
                        data.chainagePrefix = text.match(/^([A-Z]+)/i)[1];
                        const chainage = this.extractNumber(text);
                        if (chainage !== null && data.startingChainage === null) {
                            data.startingChainage = chainage;
                        }
                    }

                    if (text.match(/RL/i)) {
                        const rl = this.extractNumber(text);
                        if (rl !== null && data.startingRL === null) {
                            data.startingRL = rl;
                        }
                    }
                }
                break;
        }
    }

    /**
     * Parse DWF file (Design Web Format)
     * Note: DWF files generated by our tool contain AutoCAD script with metadata
     */
    async parseDWF(file) {
        // Read file content as text (our DWF files are text-based script files)
        const text = await this.readFileContent(file);

        const data = {
            width: null,
            startingRL: null,
            startingChainage: null,
            startLabel: null,
            endLabel: null,
            chainagePrefix: 'CH',
            segments: [],
            distanceUnits: 'm'
        };

        // Check for embedded metadata (same format as CAD scripts)
        const lines = text.split('\n').map(l => l.trim());
        const metadataStartIndex = lines.findIndex(line => line.includes('RAMP_DESIGN_METADATA_START'));
        const metadataEndIndex = lines.findIndex(line => line.includes('RAMP_DESIGN_METADATA_END'));

        if (metadataStartIndex !== -1 && metadataEndIndex !== -1 && metadataStartIndex < metadataEndIndex) {
            // Extract the JSON line between the markers
            for (let i = metadataStartIndex + 1; i < metadataEndIndex; i++) {
                const line = lines[i];
                // Remove the leading '; ' comment marker
                const jsonString = line.replace(/^;\s*/, '');
                try {
                    const metadata = JSON.parse(jsonString);
                    // Return the metadata directly - perfect roundtrip!
                    return {
                        width: metadata.width,
                        startingRL: metadata.startingRL,
                        startingChainage: metadata.startingChainage,
                        startLabel: metadata.startLabel,
                        endLabel: metadata.endLabel,
                        chainagePrefix: metadata.chainagePrefix,
                        chainagePosition: metadata.chainagePosition,
                        distanceUnits: metadata.distanceUnits,
                        gradeDisplay: metadata.gradeDisplay,
                        sectionSubtitle: metadata.sectionSubtitle,
                        planSubtitle: metadata.planSubtitle,
                        chainageDecimalPlaces: metadata.chainageDecimalPlaces,
                        rlDecimalPlaces: metadata.rlDecimalPlaces,
                        gradeDecimalPlaces: metadata.gradeDecimalPlaces,
                        segments: metadata.segments || []
                    };
                } catch (e) {
                    console.warn('Failed to parse DWF metadata:', e);
                }
            }
        }

        // Fallback to basic text extraction if no metadata found
        const numbers = text.match(/\d+\.?\d*/g);
        if (numbers && numbers.length > 0) {
            // Make educated guesses based on typical ranges
            const values = numbers.map(n => parseFloat(n)).filter(n => !isNaN(n));

            // Width typically 2-10m
            const widthCandidates = values.filter(v => v >= 2 && v <= 10);
            if (widthCandidates.length > 0) {
                data.width = widthCandidates[0];
            }

            // RL typically -100 to 1000
            const rlCandidates = values.filter(v => v >= -100 && v <= 1000);
            if (rlCandidates.length > 0) {
                data.startingRL = Math.min(...rlCandidates);
            }
        }

        console.warn('DWF file does not contain TrafficLabb metadata. Limited data extracted.');
        return data;
    }

    /**
     * Parse CAD Script file (.scr)
     */
    async parseCADScript(scriptContent) {
        const data = {
            width: null,
            startingRL: null,
            startingChainage: null,
            startLabel: null,
            endLabel: null,
            chainagePrefix: 'CH',
            segments: [],
            distanceUnits: 'm'
        };

        const lines = scriptContent.split('\n').map(l => l.trim());

        // Check for embedded metadata first
        const metadataStartIndex = lines.findIndex(line => line.includes('RAMP_DESIGN_METADATA_START'));
        const metadataEndIndex = lines.findIndex(line => line.includes('RAMP_DESIGN_METADATA_END'));

        if (metadataStartIndex !== -1 && metadataEndIndex !== -1 && metadataStartIndex < metadataEndIndex) {
            // Extract the JSON line between the markers
            for (let i = metadataStartIndex + 1; i < metadataEndIndex; i++) {
                const line = lines[i];
                // Remove the leading '; ' comment marker
                const jsonString = line.replace(/^;\s*/, '');
                try {
                    const metadata = JSON.parse(jsonString);
                    // Return the metadata directly - perfect roundtrip!
                    return {
                        width: metadata.width,
                        startingRL: metadata.startingRL,
                        startingChainage: metadata.startingChainage,
                        startLabel: metadata.startLabel,
                        endLabel: metadata.endLabel,
                        chainagePrefix: metadata.chainagePrefix,
                        chainagePosition: metadata.chainagePosition,
                        distanceUnits: metadata.distanceUnits,
                        gradeDisplay: metadata.gradeDisplay,
                        sectionSubtitle: metadata.sectionSubtitle,
                        planSubtitle: metadata.planSubtitle,
                        chainageDecimalPlaces: metadata.chainageDecimalPlaces,
                        rlDecimalPlaces: metadata.rlDecimalPlaces,
                        gradeDecimalPlaces: metadata.gradeDecimalPlaces,
                        segments: metadata.segments || []
                    };
                } catch (e) {
                    console.warn('Failed to parse CAD script metadata:', e);
                }
            }
        }

        // Fallback to heuristic parsing if no metadata found
        // Parse AutoCAD script commands
        const coordinates = [];
        const textValues = [];

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];

            // Extract LINE commands with coordinates
            if (line.toUpperCase().startsWith('LINE')) {
                // Look for coordinate pairs in following lines
                for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
                    const coordLine = lines[j];
                    const coordMatch = coordLine.match(/(-?\d+\.?\d*),(-?\d+\.?\d*)/);
                    if (coordMatch) {
                        coordinates.push({
                            x: parseFloat(coordMatch[1]),
                            y: parseFloat(coordMatch[2])
                        });
                    }
                }
            }

            // Extract TEXT commands
            if (line.toUpperCase().startsWith('TEXT') || line.toUpperCase().startsWith('-TEXT')) {
                // Text value is usually a few lines after the TEXT command
                for (let j = i + 1; j < Math.min(i + 6, lines.length); j++) {
                    const textLine = lines[j];
                    if (textLine && !textLine.match(/^-?\d+\.?\d*,?-?\d*\.?\d*$/)) {
                        textValues.push(textLine);
                    }
                }
            }
        }

        // Calculate segments from coordinates
        for (let i = 0; i < coordinates.length - 1; i++) {
            const p1 = coordinates[i];
            const p2 = coordinates[i + 1];

            const length = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
            const rise = p2.y - p1.y;
            const grade = length > 0 ? (rise / length) * 100 : 0;

            if (length > 0.01) { // Filter out very small segments
                data.segments.push({
                    length: length,
                    grade: grade
                });
            }
        }

        // Extract parameters from text values
        textValues.forEach(text => {
            if (text.toLowerCase().includes('width')) {
                const width = this.extractNumber(text);
                if (width !== null) data.width = width;
            }

            if (text.match(/^(CH|CL|ST)/i)) {
                const prefixMatch = text.match(/^([A-Z]+)/i);
                if (prefixMatch) data.chainagePrefix = prefixMatch[1];

                const chainage = this.extractNumber(text);
                if (chainage !== null && data.startingChainage === null) {
                    data.startingChainage = chainage;
                }
            }

            if (text.match(/RL/i)) {
                const rl = this.extractNumber(text);
                if (rl !== null && data.startingRL === null) {
                    data.startingRL = rl;
                }
            }

            // Check for labels
            if (text.length > 2 && !text.match(/^[\d\.\s]+$/) && !text.match(/^(CH|CL|ST|RL)/i)) {
                if (data.startLabel === null) {
                    data.startLabel = text;
                } else if (data.endLabel === null) {
                    data.endLabel = text;
                }
            }
        });

        return data;
    }

    /**
     * Extract SVG comments
     */
    extractSVGComments(svgContent) {
        const commentRegex = /<!--([\s\S]*?)-->/g;
        const comments = [];
        let match;

        while ((match = commentRegex.exec(svgContent)) !== null) {
            comments.push(match[1].trim());
        }

        return comments;
    }

    /**
     * Extract metadata from comments (JSON or key-value pairs)
     */
    extractMetadataFromComments(comments) {
        for (const comment of comments) {
            try {
                // Check for special TrafficLabb metadata format
                if (comment.startsWith('RAMP_DESIGN_METADATA:')) {
                    const jsonData = comment.substring('RAMP_DESIGN_METADATA:'.length);
                    const parsed = JSON.parse(jsonData);

                    // Convert to our expected format
                    return {
                        width: parsed.width,
                        startingRL: parsed.startingRL,
                        startingChainage: parsed.startingChainage,
                        startLabel: parsed.startLabel,
                        endLabel: parsed.endLabel,
                        chainagePrefix: parsed.chainagePrefix,
                        chainagePosition: parsed.chainagePosition,
                        distanceUnits: parsed.distanceUnits,
                        gradeDisplay: parsed.gradeDisplay,
                        sectionSubtitle: parsed.sectionSubtitle,
                        planSubtitle: parsed.planSubtitle,
                        chainageDecimalPlaces: parsed.chainageDecimalPlaces,
                        rlDecimalPlaces: parsed.rlDecimalPlaces,
                        gradeDecimalPlaces: parsed.gradeDecimalPlaces,
                        segments: parsed.segments || []
                    };
                }

                // Try to parse as JSON
                if (comment.startsWith('{')) {
                    return JSON.parse(comment);
                }

                // Try to parse as key-value pairs
                if (comment.includes(':')) {
                    const metadata = {};
                    const lines = comment.split('\n');
                    lines.forEach(line => {
                        const match = line.match(/(\w+)\s*:\s*(.+)/);
                        if (match) {
                            const key = match[1].trim();
                            let value = match[2].trim();

                            // Try to parse numbers
                            if (value.match(/^-?\d+\.?\d*$/)) {
                                value = parseFloat(value);
                            }

                            metadata[key] = value;
                        }
                    });

                    if (Object.keys(metadata).length > 0) {
                        return metadata;
                    }
                }
            } catch (e) {
                console.warn('Failed to parse metadata comment:', e);
                continue;
            }
        }

        return null;
    }

    /**
     * Extract first number from text
     */
    extractNumber(text) {
        const match = text.match(/-?\d+\.?\d*/);
        if (match) {
            const num = parseFloat(match[0]);
            return isNaN(num) ? null : num;
        }
        return null;
    }

    /**
     * Get parsed data
     */
    getData() {
        return this.parsedData;
    }
}

// Export for use in other scripts
if (typeof module !== 'undefined' && module.exports) {
    module.exports = CADFileParser;
}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traffic Labb - Ramp Design Tool</title>
    <link rel="stylesheet" href="/style.css">
    <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
    <script src="/common.js"></script>
</head>
<body>
    <div id="loading" class="loading">
        <h2>Verifying access...</h2>
    </div>

    <div id="app" class="container hidden">
        <div class="dashboard-header">
            <div class="header-left">
                <div class="header-title">
                    <h1>Ramp Design Tool</h1>
                </div>
            </div>
            <div class="header-center">
            </div>
            <div class="header-right">
                <span class="username" id="welcomeUser">Welcome, User</span>
                <button class="logout-btn" onclick="logout()">Logout</button>
            </div>
        </div>

        <div class="main-content">
            <div class="glass-card">
                <h3 class="section-title">Configuration</h3>
                
                <div class="cards-container">
                    <div class="card">
                        <div class="card-title">Basic Parameters</div>
                        <div class="form-row">
                            <div class="form-group">
                                <label for="widthInput">Ramp Width (m):</label>
                                <input type="number" id="widthInput" value="3.6" min="0.001" step="0.1" onchange="validateAndUpdate('widthInput', 0.001); updateSegmentOutputs()">
                            </div>
                            <div class="form-group">
                                <label for="startingRLInput">Starting RL (m):</label>
                                <input type="number" id="startingRLInput" value="0.000" min="-1000" max="10000" step="0.001" onchange="validateAndUpdate('startingRLInput', -1000, 10000); updateSegmentOutputs()">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group">
                                <label for="startLabelInput">Left Label:</label>
                                <input type="text" id="startLabelInput" value="Carpark" onchange="updateSegmentOutputs()">
                            </div>
                            <div class="form-group">
                                <label for="endLabelInput">Right Label:</label>
                                <input type="text" id="endLabelInput" value="Property Boundary" onchange="updateSegmentOutputs()">
                            </div>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-title">Drawing Details</div>
                        <div class="subsection">
                            <h4 class="subsection-title">Labels</h4>
                            <div class="form-row">
                                <div class="form-group">
                                    <label for="chainagePrefixInput">Chainage Label:</label>
                                    <input type="text" id="chainagePrefixInput" value="CH" placeholder="e.g. CH, CL, ST" onchange="updateSegmentOutputs()">
                                </div>
                                <div class="form-group">
                                    <label for="chainagePositionSelect">Label Position:</label>
                                    <select id="chainagePositionSelect" onchange="updateChainagePosition(this.value)" class="form-select">
                                        <option value="prefix">Prefix (CH1.5m)</option>
                                        <option value="suffix">Suffix (1.5m CH)</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        
                        <div class="subsection">
                            <h4 class="subsection-title">Drawing Precision</h4>
                            <div class="form-row">
                                <div class="form-group">
                                    <label for="chainageDecimalInput">CH Decimal Places:</label>
                                    <input type="number" id="chainageDecimalInput" value="2" min="0" max="4" step="1" onchange="validateAndUpdate('chainageDecimalInput', 0, 3); updateSegmentOutputs()">
                                </div>
                                <div class="form-group">
                                    <label for="rlDecimalInput">RL Decimal Places:</label>
                                    <input type="number" id="rlDecimalInput" value="2" min="0" max="3" step="1" onchange="validateAndUpdate('rlDecimalInput', 0, 3); updateSegmentOutputs()">
                                </div>
                            </div>
                            <div class="form-row">
                                <div class="form-group">
                                    <label for="gradeDecimalInput">Grade Decimal Places:</label>
                                    <input type="number" id="gradeDecimalInput" value="1" min="0" max="4" step="1" onchange="validateAndUpdate('gradeDecimalInput', 0, 2); updateSegmentOutputs()">
                                </div>
                            </div>
                        </div>
                        
                        <div class="subsection">
                            <h4 class="subsection-title">Units</h4>
                            <div class="form-row">
                                <div class="form-group">
                                    <label for="distanceUnitsSelect">Distance Units:</label>
                                    <select id="distanceUnitsSelect" onchange="updateDistanceUnits(this.value)" class="form-select">
                                        <option value="m">Metres (m)</option>
                                        <option value="mm">Millimetres (mm)</option>
                                    </select>
                                </div>
                                <div class="form-group">
                                    <label for="gradeDisplaySelect">Grade Display:</label>
                                    <select id="gradeDisplaySelect" onchange="updateGradeDisplay(this.value)" class="form-select">
                                        <option value="percent">Percentage (%)</option>
                                        <option value="ratio">Ratio (1:X)</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <div class="card-title">Ramp Segments</div>
                    <div style="margin-bottom: 15px;">
                        <button class="btn btn-reset" onclick="resetSegments()">Reset</button>
                    </div>
                    
                    <div class="table-section">
                        <table class="table" id="segmentsTable">
                            <thead>
                                <tr>
                                    <th>ID</th>
                                    <th class="narrow-column">
                                        <select id="lengthInputType" onchange="setLengthInputType(this.value)" class="header-dropdown">
                                            <option value="length">Length (m)</option>
                                            <option value="chainage">Chainage (m)</option>
                                        </select>
                                    </th>
                                    <th class="narrow-column">
                                        <select id="gradeInputType" onchange="setGradeInputType(this.value)" class="header-dropdown">
                                            <option value="rl">RL (m)</option>
                                            <option value="percent" selected>Grade (%)</option>
                                            <option value="ratio">Grade (1:X)</option>
                                        </select>
                                    </th>
                                    <th>Chainage at End (m)</th>
                                    <th>RL at End (m)</th>
                                    <th>Add Below</th>
                                    <th>Remove</th>
                                </tr>
                            </thead>
                            <tbody id="segmentsTableBody">
                                <!-- Segments will be added here -->
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <div class="buttons-row">
                    <button class="btn btn-reset" id="resetButton" onclick="resetInputs()">Reset Inputs</button>
                    <button class="btn btn-run" id="generateButton" onclick="generateRampDesign()">Generate Ramp Design</button>
                </div>
                
                <div class="status" id="status" style="display: none;"></div>
            </div>

            <div class="results-container">
                <h3 class="section-title">Technical Drawings</h3>
                
                <div id="drawingsContent">
                    <div class="no-results">
                        <h4>Drawings will appear here</h4>
                        <p>Generate ramp design to view section and plan views</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <style>
        /* Additional styles for ramp-specific elements */
        #segmentsTable {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border: 1px solid #a3c9e0;
            border-radius: 6px;
            overflow: hidden;
            table-layout: fixed;
        }

        #segmentsTable th {
            background: #e3f1f7;
            color: #354e8d;
            padding: 10px 8px;
            text-align: center;
            font-weight: 600;
            border-bottom: 1px solid #a3c9e0;
            font-size: 0.9rem;
        }

        #segmentsTable td {
            padding: 8px;
            border-bottom: 1px solid #e3f1f7;
            text-align: center;
            font-size: 0.9rem;
        }

        #segmentsTable tr:hover {
            background: #f8f9fa;
        }

        .narrow-column {
            width: 120px;
            min-width: 120px;
            max-width: 120px;
        }

        #segmentsTable input[type="number"] {
            width: 60px !important;
            padding: 3px 4px !important;
            border: 1px solid #a3c9e0 !important;
            border-radius: 3px !important;
            text-align: center !important;
            font-size: 0.8rem !important;
            box-sizing: border-box !important;
        }

        #segmentsTable input[type="number"]:focus {
            outline: none !important;
            border-color: #6b99c2 !important;
        }

        #segmentsTable input[type="number"]:disabled {
            background: #f8f9fa !important;
            color: #6c757d !important;
            cursor: not-allowed !important;
        }

        .output-cell {
            background: #f0f7ff;
            color: #6c757d;
            font-weight: 400;
            font-size: 0.8rem;
        }

        .starting-row {
            background: #e3f1f7;
            font-weight: 600;
        }

        .starting-row td {
            background: #e3f1f7;
        }

        .btn-remove {
            background: #dc3545;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .btn-remove:hover {
            background: #c82333;
        }

        .btn-add {
            background: #28a745;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .btn-add:hover {
            background: #218838;
        }

        .header-dropdown {
            background: white;
            border: 1px solid #a3c9e0;
            border-radius: 4px;
            color: #354e8d;
            font-weight: 600;
            font-size: 0.75rem;
            cursor: pointer;
            text-align: center;
            width: 100%;
            max-width: 110px;
            padding: 3px 2px;
            box-sizing: border-box;
        }

        .header-dropdown:focus {
            outline: 1px solid #6b99c2;
        }

        .header-dropdown option {
            font-size: 0.75rem;
        }

        /* Subsection Styles */
        .subsection {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border: 1px solid #e3f1f7;
            border-radius: 6px;
        }

        .subsection:last-child {
            margin-bottom: 0;
        }

        .subsection-title {
            margin: 0 0 12px 0;
            padding: 0;
            font-size: 0.9rem;
            font-weight: 600;
            color: #354e8d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #a3c9e0;
            padding-bottom: 6px;
        }

        /* Form Select Styles */
        .form-select {
            padding: 8px 12px;
            border: 1px solid #a3c9e0;
            border-radius: 4px;
            background: white;
            color: #2c2c2c;
            font-size: 0.9rem;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            cursor: pointer;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
            width: 100%;
            box-sizing: border-box;
        }

        .form-select:focus {
            outline: none;
            border-color: #6b99c2;
            box-shadow: 0 0 0 3px rgba(107, 153, 194, 0.1);
        }

        .form-select:hover {
            border-color: #6b99c2;
        }

        .drawing-section {
            margin-bottom: 20px;
            background: #f8f9fa;
            border: 1px solid #e3f1f7;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .drawing-header {
            background: linear-gradient(135deg, #354e8d 0%, #496f9c 100%);
            color: white;
            padding: 12px 16px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.1rem;
        }
        
        .drawing-content {
            padding: 15px;
            background: #fafafa;
            text-align: center;
        }
        
        .drawing-content svg {
            max-width: 100%;
            height: auto;
            background: white;
            border: 1px solid #a3c9e0;
            border-radius: 4px;
        }
        
        /* Enhanced Export Buttons - Traffic Labb Style */
        .export-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .btn-export {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            min-width: 80px;
            justify-content: center;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }
        
        /* Primary Export Buttons (SVG, CAD) */
        .btn-export {
            background: rgba(255, 255, 255, 0.9);
            color: #354e8d;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .btn-export:hover {
            background: white;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        /* SVG Button - Blue Theme */
        .btn-export.svg {
            background: #87ceeb;
            color: #2c2c2c;
            border: 1px solid #7bb8d9;
        }
        
        .btn-export.svg:hover {
            background: #7bb8d9;
            color: #2c2c2c;
        }
        
        /* PDF Button - Orange Theme */
        .btn-export.pdf {
            background: linear-gradient(135deg, #e67e22 0%, #d35400 100%);
            color: white;
        }
        
        .btn-export.pdf:hover {
            background: linear-gradient(135deg, #d35400 0%, #c0392b 100%);
        }
        
        /* PNG Button - Green Theme */
        .btn-export.png {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            color: white;
        }
        
        .btn-export.png:hover {
            background: linear-gradient(135deg, #229954 0%, #1e8449 100%);
        }
        
        /* Loading State */
        .btn-export.loading {
            opacity: 0.8;
            cursor: wait;
            transform: none !important;
        }
        
        .btn-export.loading::before {
            content: '⟳ ';
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        /* Disabled State */
        .btn-export:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1) !important;
        }

        /* Input Validation Styles */
        .corrected-value {
            border-color: #d4691e !important;
            background-color: rgba(212, 105, 30, 0.1) !important;
            transition: all 0.3s ease;
        }
        
        .validation-warning {
            color: #d4691e;
            font-size: 0.8rem;
            margin-top: 4px;
            animation: fadeInOut 3s ease-in-out;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-5px); }
            20% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-5px); }
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            #segmentsTable {
                font-size: 0.8rem;
            }
            
            #segmentsTable th,
            #segmentsTable td {
                padding: 6px 4px;
            }
            
            #segmentsTable input[type="number"] {
                width: 60px !important;
                font-size: 0.75rem !important;
            }
            
            .export-buttons {
                gap: 6px;
            }
            
            .btn-export {
                font-size: 0.75rem;
                padding: 6px 10px;
                min-width: 70px;
            }
            
            .drawing-header {
                flex-direction: column;
                gap: 8px;
                align-items: stretch;
            }
        }

        @media (max-width: 480px) {
            .export-buttons {
                flex-direction: column;
                gap: 4px;
                width: 100%;
            }
            
            .btn-export {
                width: 100%;
                min-width: unset;
            }
        }
    </style>

    <script>
        let currentLengthInputType = 'length';
        let currentGradeInputType = 'percent';
        let currentDistanceUnits = 'm';
        let currentGradeDisplay = 'percent';
        let currentChainagePosition = 'prefix';
        let chainageDecimalPlaces = 1;
        let rlDecimalPlaces = 3;
        let gradeDecimalPlaces = 1;
        let segments = [];
        let segmentCounter = 0;

        /**
         * Handle chainage position change (prefix/suffix)
         */
        function updateChainagePosition(position) {
            currentChainagePosition = position;
            updateSegmentOutputs();
        }

        /**
         * Format distance value with specified decimal places for drawings
         */
        function formatDistanceValueForDrawing(value, decimalPlaces) {
            if (currentDistanceUnits === 'mm') {
                const convertedValue = value * 1000;
                return convertedValue.toFixed(decimalPlaces);
            }
            return value.toFixed(decimalPlaces);
        }

        /**
         * Format chainage label with proper positioning and decimal places
         */
        function formatChainageLabel(value, prefix = 'CH') {
            const formattedValue = formatDistanceValueForDrawing(value, chainageDecimalPlaces);
            const unit = currentDistanceUnits;
            
            if (currentChainagePosition === 'suffix') {
                return `${formattedValue}${unit} ${prefix}`;
            } else {
                return `${prefix}${formattedValue}${unit}`;
            }
        }

        /**
         * Handle distance units change (m/mm)
         */
        function updateDistanceUnits(units) {
            currentDistanceUnits = units;
            updateSegmentOutputs();
            
            // Update the ramp width label
            const widthLabel = document.querySelector('label[for="widthInput"]');
            if (widthLabel) {
                widthLabel.textContent = `Ramp Width (${units}):`;
            }
            
            // Update the starting RL label
            const startingRLLabel = document.querySelector('label[for="startingRLInput"]');
            if (startingRLLabel) {
                startingRLLabel.textContent = `Starting RL (${units}):`;
            }
            
            // Update table headers to show current units
            const lengthHeader = document.querySelector('#lengthInputType');
            if (lengthHeader) {
                const selectedOption = lengthHeader.selectedOptions[0];
                if (selectedOption.value === 'length') {
                    selectedOption.textContent = `Length (${units})`;
                } else {
                    selectedOption.textContent = `Chainage (${units})`;
                }
                // Update all options
                Array.from(lengthHeader.options).forEach(option => {
                    if (option.value === 'length') {
                        option.textContent = `Length (${units})`;
                    } else {
                        option.textContent = `Chainage (${units})`;
                    }
                });
            }
        }

        /**
         * Handle grade display change (%/1:x)
         */
        function updateGradeDisplay(displayType) {
            currentGradeDisplay = displayType;
            updateSegmentOutputs();
        }

        /**
         * Get display value with proper units
         */
        function formatDistanceValue(value, precision = null) {
            if (currentDistanceUnits === 'mm') {
                // Use 0 decimal places for mm (whole numbers)
                const actualPrecision = precision !== null ? precision : 0;
                return (value * 1000).toFixed(actualPrecision);
            }
            // Use 3 decimal places formetres
            const actualPrecision = precision !== null ? precision : 3;
            return value.toFixed(actualPrecision);
        }

        /**
         * Get grade display value based on current display setting
         */
        function formatGradeForDisplay(gradePercent) {
            if (currentGradeDisplay === 'ratio') {
                if (gradePercent === 0) return '∞';
                const ratio = Math.abs(100 / gradePercent);
                return `1:${ratio.toFixed(1)}`;
            }
            return `${gradePercent.toFixed(1)}%`;
        }

        /**
         * Validates and corrects input values to prevent negative/invalid entries
         * @param {string} inputId - The ID of the input element
         * @param {number} minValue - Minimum allowed value (inclusive)
         * @param {number} maxValue - Maximum allowed value (optional)
         */
        function validateAndUpdate(inputId, minValue, maxValue = null) {
            const input = document.getElementById(inputId);
            if (!input) return;
            
            let value = parseFloat(input.value);
            
            // Handle NaN or empty values
            if (isNaN(value) || input.value.trim() === '') {
                value = minValue;
            }
            
            // Apply minimum constraint
            if (value < minValue) {
                value = minValue;
                showValidationWarning(inputId, `Value cannot be less than ${minValue}`);
            }
            
            // Apply maximum constraint if specified
            if (maxValue !== null && value > maxValue) {
                value = maxValue;
                showValidationWarning(inputId, `Value cannot be greater than ${maxValue}`);
            }
            
            // Update input value if it was corrected
            if (parseFloat(input.value) !== value) {
                input.value = value;
                input.classList.add('corrected-value');
                
                // Remove highlight after 2 seconds
                setTimeout(() => {
                    input.classList.remove('corrected-value');
                }, 2000);
            }
        }

        /**
         * Show temporary validation warning
         */
        function showValidationWarning(inputId, message) {
            // Remove existing warnings for this input
            const existingWarning = document.getElementById(`warning-${inputId}`);
            if (existingWarning) {
                existingWarning.remove();
            }
            
            // Create and show new warning
            const input = document.getElementById(inputId);
            const warning = document.createElement('div');
            warning.id = `warning-${inputId}`;
            warning.className = 'validation-warning';
            warning.textContent = message;
            
            input.parentNode.appendChild(warning);
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (warning.parentNode) {
                    warning.parentNode.removeChild(warning);
                }
            }, 3000);
        }

        /**
         * Validate all inputs before generating ramp design
         */
        function validateAllInputs() {
            let isValid = true;
            const validationRules = [
                { id: 'widthInput', min: 0.001, name: 'Ramp Width' },
                { id: 'startingRLInput', min: -1000, max: 10000, name: 'Starting RL' },
                { id: 'chainageDecimalInput', min: 0, max: 3, name: 'CH Decimal Places' },
                { id: 'rlDecimalInput', min: 0, max: 3, name: 'RL Decimal Places' },
                { id: 'gradeDecimalInput', min: 0, max: 2, name: 'Grade Decimal Places' }
            ];
            
            validationRules.forEach(rule => {
                const input = document.getElementById(rule.id);
                if (input) {
                    const value = parseFloat(input.value);
                    if (isNaN(value) || value < rule.min || (rule.max && value > rule.max)) {
                        showValidationWarning(rule.id, `${rule.name} must be valid`);
                        isValid = false;
                    }
                }
            });
            
            // Validate segment lengths
            segments.forEach(segment => {
                const lengthInput = document.getElementById(`length-${segment.id}`);
                if (lengthInput) {
                    const value = parseFloat(lengthInput.value);
                    if (isNaN(value) || value < 0.001) {
                        showValidationWarning(`length-${segment.id}`, 'Length must be at least 0.001m');
                        isValid = false;
                    }
                }
            });
            
            return isValid;
        }

        /**
         * Update decimal places from inputs
         */
        function updateDecimalPlaces() {
            chainageDecimalPlaces = parseInt(document.getElementById('chainageDecimalInput').value);
            rlDecimalPlaces = parseInt(document.getElementById('rlDecimalInput').value);
            gradeDecimalPlaces = parseInt(document.getElementById('gradeDecimalInput').value);
        }

        // Authentication check on page load
        document.addEventListener('DOMContentLoaded', () => {
            const token = localStorage.getItem('authToken');
            
            if (!token || !isValidToken(token)) {
                window.location.href = '/';
                return;
            }
            
            updateWelcomeMessage();
            document.getElementById('loading').style.display = 'none';
            document.getElementById('app').classList.remove('hidden');
            initializeDefaultSegments();
            setupDashboardFeedbackForm();
        });

        function isValidToken(token) {
            try {
                const decoded = atob(token);
                const [timestamp, username] = decoded.split(':');
                const tokenAge = Date.now() - parseInt(timestamp);
                return tokenAge < 24 * 60 * 60 * 1000;
            } catch {
                return false;
            }
        }

        function getUsernameFromToken() {
            try {
                const token = localStorage.getItem('authToken');
                if (!token) return 'User';
                
                const decoded = atob(token);
                const [timestamp, username] = decoded.split(':');
                return username || 'User';
            } catch {
                return 'User';
            }
        }

        function updateWelcomeMessage() {
            const username = getUsernameFromToken();
            document.getElementById('welcomeUser').textContent = `Welcome, ${username}`;
        }

        function logout() {
            localStorage.removeItem('authToken');
            window.location.href = '/';
        }

        // Synchronize segment data from DOM inputs to segments array
        function syncSegmentDataFromDOM() {
            segments.forEach(segment => {
                const lengthInput = document.getElementById(`length-${segment.id}`);
                const gradeInput = document.getElementById(`grade-${segment.id}`);
                
                if (lengthInput) {
                    // Validate length input
                    const lengthValue = parseFloat(lengthInput.value);
                    if (isNaN(lengthValue) || lengthValue < 0.001) {
                        lengthInput.value = 0.001;
                        segment.length = 0.001;
                    } else {
                        segment.length = lengthValue;
                    }
                }
                if (gradeInput) {
                    // Grade can be negative, so no minimum validation
                    const gradeValue = parseFloat(gradeInput.value);
                    segment.grade = isNaN(gradeValue) ? 0 : gradeValue;
                }
            });
        }

        function setLengthInputType(type) {
            const oldType = currentLengthInputType;
            currentLengthInputType = type;
            
            if (oldType !== type) {
                // Sync current DOM values to segments array before conversion
                syncSegmentDataFromDOM();
                convertAllLengthInputs(oldType, type);
            }
            
            renderSegments();
            updateSegmentOutputs();
        }

        function setGradeInputType(type) {
            const oldType = currentGradeInputType;
            currentGradeInputType = type;
            
            if (oldType !== type) {
                // Sync current DOM values to segments array before conversion
                syncSegmentDataFromDOM();
                convertAllGradeInputs(oldType, type);
            }
            
            renderSegments();
            updateSegmentOutputs();
        }

        function convertAllLengthInputs(fromType, toType) {
            // Store current DOM values before conversion
            const currentValues = segments.map(segment => {
                const input = document.getElementById(`length-${segment.id}`);
                return input ? parseFloat(input.value) || 0 : segment.length;
            });
            
            segments.forEach((segment, index) => {
                const currentValue = currentValues[index];
                let convertedValue;
                
                if (fromType === 'length' && toType === 'chainage') {
                    let chainageAtEnd = 0;
                    for (let i = 0; i <= index; i++) {
                        chainageAtEnd += currentValues[i];
                    }
                    convertedValue = chainageAtEnd;
                } else if (fromType === 'chainage' && toType === 'length') {
                    const previousChainage = index === 0 ? 0 : currentValues[index - 1];
                    convertedValue = Math.max(0.001, currentValue - previousChainage);
                }
                
                if (convertedValue !== undefined) {
                    segment.length = convertedValue;
                }
            });
        }

        function convertAllGradeInputs(fromType, toType) {
            let cumulativeRL = parseFloat(document.getElementById('startingRLInput').value);
            
            segments.forEach((segment, index) => {
                const currentValue = segment.grade;
                const segmentLength = getSegmentActualLength(segment.id);
                let convertedValue;
                
                if (fromType === 'rl' && toType === 'percent') {
                    if (segmentLength > 0) {
                        const rise = currentValue - cumulativeRL;
                        convertedValue = (rise / segmentLength) * 100;
                        cumulativeRL = currentValue;
                    } else {
                        convertedValue = 0;
                    }
                } else if (fromType === 'rl' && toType === 'ratio') {
                    if (segmentLength > 0) {
                        const rise = currentValue - cumulativeRL;
                        const gradePercent = (rise / segmentLength) * 100;
                        convertedValue = gradePercent !== 0 ? Math.abs(100 / gradePercent) : 0;
                        cumulativeRL = currentValue;
                    } else {
                        convertedValue = 0;
                    }
                } else if (fromType === 'percent' && toType === 'rl') {
                    const rise = (currentValue / 100) * segmentLength;
                    convertedValue = cumulativeRL + rise;
                    cumulativeRL = convertedValue;
                } else if (fromType === 'percent' && toType === 'ratio') {
                    convertedValue = currentValue !== 0 ? Math.abs(100 / currentValue) : 0;
                    const rise = (currentValue / 100) * segmentLength;
                    cumulativeRL += rise;
                } else if (fromType === 'ratio' && toType === 'rl') {
                    const gradePercent = currentValue !== 0 ? 100 / currentValue : 0;
                    const rise = (gradePercent / 100) * segmentLength;
                    convertedValue = cumulativeRL + rise;
                    cumulativeRL = convertedValue;
                } else if (fromType === 'ratio' && toType === 'percent') {
                    convertedValue = currentValue !== 0 ? 100 / currentValue : 0;
                    const rise = (convertedValue / 100) * segmentLength;
                    cumulativeRL += rise;
                }
                
                if (convertedValue !== undefined) {
                    segment.grade = convertedValue;
                }
            });
        }

        function getSegmentActualLength(segmentId) {
            const segment = segments.find(s => s.id === segmentId);
            if (!segment) return 0;
            
            if (currentLengthInputType === 'length') {
                return segment.length;
            } else {
                const segmentIndex = segments.findIndex(s => s.id === segmentId);
                let previousChainage = 0;
                for (let i = 0; i < segmentIndex; i++) {
                    previousChainage = segments[i].length;
                }
                return Math.max(0, segment.length - previousChainage);
            }
        }

        function addSegment() {
            const segmentId = ++segmentCounter;
            
            let defaultLength = 1; // Default to 1m instead of 0
            let defaultGrade = 0;
            
            if (currentLengthInputType === 'chainage') {
                defaultLength = segments.reduce((sum, seg) => sum + getSegmentActualLength(seg.id), 0) + 1;
            }
            
            if (currentGradeInputType === 'rl') {
                const segmentIndex = segments.length;
                defaultGrade = getSegmentStartingRL(segmentIndex);
            } else if (currentGradeInputType === 'percent') {
                defaultGrade = 0;
            } else if (currentGradeInputType === 'ratio') {
                defaultGrade = 0;
            }
            
            const segment = { id: segmentId, length: defaultLength, grade: defaultGrade };
            segments.push(segment);
            
            renderSegments();
            updateSegmentOutputs();
        }

        function removeSegment(segmentId) {
            segments = segments.filter(s => s.id !== segmentId);
            renderSegments();
            updateSegmentOutputs();
        }

        function renderSegments() {
            const tableBody = document.getElementById('segmentsTableBody');
            const startingRL = parseFloat(document.getElementById('startingRLInput').value);
            
            let html = `
                <tr class="starting-row">
                    <td>0</td>
                    <td>-</td>
                    <td>-</td>
                    <td>0.000</td>
                    <td>${startingRL.toFixed(3)}</td>
                    <td><button class="btn-add" onclick="addSegmentBelow(0)">+</button></td>
                    <td>-</td>
                </tr>
            `;
            
            html += segments.map((segment, index) => {
                return `
                    <tr>
                        <td>${segment.id}</td>
                        <td>
                            <input type="number" id="length-${segment.id}" value="${segment.length.toFixed(3)}" 
                                   min="0.001" step="0.1" onchange="validateAndUpdate('length-${segment.id}', 0.001); updateSegmentOutputs()">
                        </td>
                        <td>
                            <input type="number" id="grade-${segment.id}" value="${segment.grade.toFixed(3)}" 
                                   step="0.1" onchange="updateSegmentOutputs()">
                        </td>
                        <td class="output-cell" id="chainage-output-${segment.id}">0.000</td>
                        <td class="output-cell" id="rl-output-${segment.id}">0.000</td>
                        <td><button class="btn-add" onclick="addSegmentBelow(${segment.id})">+</button></td>
                        <td>
                            <button class="btn-remove" onclick="removeSegment(${segment.id})">-</button>
                        </td>
                    </tr>
                `;
            }).join('');
            
            tableBody.innerHTML = html;
        }

        function addSegmentBelow(afterId) {
            const segmentId = ++segmentCounter;
            
            let insertIndex = 0;
            if (afterId !== 0) {
                insertIndex = segments.findIndex(seg => seg.id === afterId) + 1;
            }
            
            let defaultLength = 1; // Default to 1m instead of 0
            let defaultGrade = 0;
            
            if (currentLengthInputType === 'chainage') {
                let cumulativeLength = 0;
                for (let i = 0; i < insertIndex; i++) {
                    cumulativeLength += getSegmentActualLength(segments[i].id);
                }
                defaultLength = cumulativeLength + 1;
            }
            
            if (currentGradeInputType === 'rl') {
                defaultGrade = getSegmentStartingRL(insertIndex);
            } else if (currentGradeInputType === 'percent') {
                defaultGrade = 0;
            } else if (currentGradeInputType === 'ratio') {
                defaultGrade = 0;
            }
            
            const segment = { id: segmentId, length: defaultLength, grade: defaultGrade };
            segments.splice(insertIndex, 0, segment);
            
            renderSegments();
            updateSegmentOutputs();
        }

        function getSegmentStartingRL(segmentIndex) {
            const startingRL = parseFloat(document.getElementById('startingRLInput').value);
            let cumulativeRL = startingRL;
            
            for (let i = 0; i < segmentIndex; i++) {
                const segment = segments[i];
                const segmentLength = getSegmentActualLength(segment.id);
                
                let rise = 0;
                if (currentGradeInputType === 'rl') {
                    const prevStartingRL = i === 0 ? startingRL : getSegmentStartingRL(i);
                    rise = segment.grade - prevStartingRL;
                } else if (currentGradeInputType === 'percent') {
                    rise = (segment.grade / 100) * segmentLength;
                } else if (currentGradeInputType === 'ratio') {
                    const gradePercent = segment.grade !== 0 ? 100 / segment.grade : 0;
                    rise = (gradePercent / 100) * segmentLength;
                }
                
                cumulativeRL += rise;
            }
            
            return cumulativeRL;
        }

        function resetSegments() {
            // Clear validation warnings
            document.querySelectorAll('.validation-warning').forEach(warning => {
                warning.remove();
            });
            document.querySelectorAll('.corrected-value').forEach(input => {
                input.classList.remove('corrected-value');
            });
            
            segments = [];
            segmentCounter = 0;
            initializeDefaultSegments();
        }

        function initializeDefaultSegments() {
            segments = [];
            segmentCounter = 0;

            // Reset basic parameters
            document.getElementById('widthInput').value = 3.6;
            document.getElementById('startingRLInput').value = 0.000;
            document.getElementById('startLabelInput').value = "Carpark";
            document.getElementById('endLabelInput').value = "Property Boundary";

            // Reset drawing details
            document.getElementById('chainagePrefixInput').value = "CH";
            document.getElementById('chainagePositionSelect').value = "prefix";
            document.getElementById('distanceUnitsSelect').value = "m";
            document.getElementById('gradeDisplaySelect').value = "percent";
            document.getElementById('chainageDecimalInput').value = 1;
            document.getElementById('rlDecimalInput').value = 3;
            document.getElementById('gradeDecimalInput').value = 1;
            
            // Update global variables
            currentDistanceUnits = 'm';
            currentGradeDisplay = 'percent';
            currentChainagePosition = 'prefix';
            chainageDecimalPlaces = 1;
            rlDecimalPlaces = 3;
            gradeDecimalPlaces = 1;
            currentLengthInputType = 'length';
            currentGradeInputType = 'percent';
            
            document.getElementById('lengthInputType').value = 'length';
            document.getElementById('gradeInputType').value = 'percent';

            // Update labels to reflect current units
            updateDistanceUnits('m');

            const defaults = [
                { length: 2, grade: 12.5 },
                { length: 12, grade: 25 },
                { length: 2, grade: 17.5 },
                { length: 6, grade: 5 },
                { length: 6, grade: 0 }
            ];

            defaults.forEach(def => {
                const segmentId = ++segmentCounter;
                segments.push({ id: segmentId, length: def.length, grade: def.grade });
            });

            renderSegments();
            updateSegmentOutputs();
        }

        function resetInputs() {
            // Clear validation warnings
            document.querySelectorAll('.validation-warning').forEach(warning => {
                warning.remove();
            });
            document.querySelectorAll('.corrected-value').forEach(input => {
                input.classList.remove('corrected-value');
            });
            
            initializeDefaultSegments();
        }

        function updateSegmentOutputs() {
            // Sync DOM values to segments array first
            syncSegmentDataFromDOM();
            
            // Update decimal places from inputs
            updateDecimalPlaces();
            
            const startingRL = parseFloat(document.getElementById('startingRLInput').value) ;
            let cumulativeLength = 0;
            let cumulativeRL = startingRL;
            
            const startingRLCells = document.querySelectorAll('.starting-row td');
            if (startingRLCells.length > 4) {
                startingRLCells[4].textContent = formatDistanceValue(startingRL);
            }
            
            segments.forEach((segment, index) => {
                const segmentLength = getSegmentActualLength(segment.id);
                cumulativeLength += segmentLength;
                
                const gradeValue = segment.grade;
                
                let rise = 0;
                let endRL = 0;
                
                if (currentGradeInputType === 'rl') {
                    endRL = gradeValue;
                    rise = endRL - cumulativeRL;
                } else if (currentGradeInputType === 'percent') {
                    rise = (gradeValue / 100) * segmentLength;
                    endRL = cumulativeRL + rise;
                } else if (currentGradeInputType === 'ratio') {
                    const gradePercent = gradeValue !== 0 ? 100 / gradeValue : 0;
                    rise = (gradePercent / 100) * segmentLength;
                    endRL = cumulativeRL + rise;
                }
                
                cumulativeRL = endRL;
                
                const chainageOutput = document.getElementById(`chainage-output-${segment.id}`);
                const rlOutput = document.getElementById(`rl-output-${segment.id}`);
                
                if (chainageOutput) chainageOutput.textContent = formatDistanceValue(cumulativeLength);
                if (rlOutput) rlOutput.textContent = formatDistanceValue(endRL);
            });
            
            // Update table headers with current units
            updateTableHeaders();
        }

        function updateTableHeaders() {
            const chainageHeader = document.querySelector('th:nth-child(4)');
            const rlHeader = document.querySelector('th:nth-child(5)');
            
            if (chainageHeader) {
                chainageHeader.textContent = `Chainage at End (${currentDistanceUnits})`;
            }
            if (rlHeader) {
                rlHeader.textContent = `RL at End (${currentDistanceUnits})`;
            }
        }

        function getSegmentData() {
            // Sync data first
            syncSegmentDataFromDOM();
            
            return segments.map((segment, index) => {
                const segmentLength = getSegmentActualLength(segment.id);
                const gradeValue = segment.grade;
                
                let gradePercent = 0;
                
                if (currentGradeInputType === 'rl') {
                    const startingRL = getSegmentStartingRL(index);
                    const rise = gradeValue - startingRL;
                    gradePercent = segmentLength > 0 ? (rise / segmentLength) * 100 : 0;
                } else if (currentGradeInputType === 'percent') {
                    gradePercent = gradeValue;
                } else if (currentGradeInputType === 'ratio') {
                    gradePercent = gradeValue !== 0 ? 100 / gradeValue : 0;
                }
                
                return {
                    length: segmentLength,
                    gradePercent: gradePercent,
                    rise: (gradePercent / 100) * segmentLength
                };
            }).filter(seg => seg.length > 0);
        }

        async function generateRampDesign() {
            const button = document.getElementById('generateButton');
            const status = document.getElementById('status');
            const token = localStorage.getItem('authToken');

            if (!token || !isValidToken(token)) {
                window.location.href = '/';
                return;
            }

            // Validate all inputs before proceeding
            if (!validateAllInputs()) {
                status.style.display = 'block';
                status.className = 'status error';
                status.textContent = 'Please correct the input validation errors before generating.';
                return;
            }

            // Update decimal places from inputs
            updateDecimalPlaces();

            // Update decimal places from inputs
            updateDecimalPlaces();

            const segmentData = getSegmentData();
            const width = parseFloat(document.getElementById('widthInput').value);
            const startingRL = parseFloat(document.getElementById('startingRLInput').value) ;
            const startLabel = document.getElementById('startLabelInput').value || 'Start';
            const endLabel = document.getElementById('endLabelInput').value || 'End';
            const chainagePrefix = document.getElementById('chainagePrefixInput').value || 'CH';

            if (!width || segmentData.length === 0) {
                status.style.display = 'block';
                status.className = 'status error';
                status.textContent = 'Please fill in ramp width and add at least one segment';
                return;
            }

            button.disabled = true;
            button.textContent = 'Generating...';
            status.style.display = 'block';
            status.className = 'status running';
            status.textContent = 'Generating ramp design drawings...';

            try {
                const response = await fetch('/api/rampdrawer', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        action: 'generateDrawings',
                        parameters: {
                            segmentData,
                            width,
                            startingRL,
                            startLabel,
                            endLabel,
                            chainagePrefix,
                            chainagePosition: currentChainagePosition,
                            chainageDecimalPlaces,
                            rlDecimalPlaces,
                            gradeDecimalPlaces,
                            distanceUnits: currentDistanceUnits,
                            gradeDisplay: currentGradeDisplay,
                            gradeType: 'percent'
                        }
                    })
                });

                if (response.status === 401) {
                    localStorage.removeItem('authToken');
                    window.location.href = '/';
                    return;
                }

                const data = await response.json();

                if (data.success) {
                    status.className = 'status complete';
                    status.textContent = 'Ramp design generated successfully!';
                    
                    displayDrawings(data.drawings);

                    setTimeout(() => {
                        status.style.display = 'none';
                    }, 3000);
                } else {
                    throw new Error(data.error || 'Failed to generate drawings');
                }

            } catch (error) {
                status.className = 'status error';
                status.textContent = 'Error: ' + error.message;
            }

            button.disabled = false;
            button.textContent = 'Generate Ramp Design';
        }

        function displayDrawings(drawings) {
            const container = document.getElementById('drawingsContent');
            
            container.innerHTML = `
                <div class="drawing-section">
                    <div class="drawing-header">
                        <span>Section View</span>
                        <div class="export-buttons">
                            <button class="btn-export svg" onclick="exportFile('section', 'svg')">SVG</button>
                            <button class="btn-export" onclick="exportFile('section', 'autocad')">CAD Script</button>
                            <button class="btn-export" onclick="exportFile('section', 'dwf')">DWF</button>
                        </div>
                    </div>
                    <div class="drawing-content">
                        ${drawings.sectionSvg}
                    </div>
                </div>
                
                <div class="drawing-section">
                    <div class="drawing-header">
                        <span>Plan View</span>
                        <div class="export-buttons">
                            <button class="btn-export svg" onclick="exportFile('plan', 'svg')">SVG</button>
                            <button class="btn-export" onclick="exportFile('plan', 'autocad')">CAD Script</button>
                            <button class="btn-export" onclick="exportFile('plan', 'dwf')">DWF</button>
                        </div>
                    </div>
                    <div class="drawing-content">
                        ${drawings.planSvg}
                    </div>
                </div>
            `;
            
            setTimeout(() => {
                const resultsContainer = document.querySelector('.results-container');
                resultsContainer.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start'
                });
            }, 100);
        }

        async function exportFile(type, format) {
            const token = localStorage.getItem('authToken');

            if (!token || !isValidToken(token)) {
                window.location.href = '/';
                return;
            }

            // Show loading state
            const button = event.target;
            const originalText = button.textContent;
            button.disabled = true;
            button.classList.add('loading');
            button.textContent = 'Generating...';

            const segmentData = getSegmentData();
            const width = parseFloat(document.getElementById('widthInput').value);
            const startingRL = parseFloat(document.getElementById('startingRLInput').value) ;
            const startLabel = document.getElementById('startLabelInput').value || 'Start';
            const endLabel = document.getElementById('endLabelInput').value || 'End';
            const chainagePrefix = document.getElementById('chainagePrefixInput').value || 'CH';

            try {
                const action = format === 'autocad' ? 'exportAutoCAD' : 'exportFile';
                const response = await fetch('/api/rampdrawer', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        action: action,
                        parameters: {
                            type,
                            format,
                            segmentData,
                            width,
                            startingRL,
                            startLabel,
                            endLabel,
                            chainagePrefix,
                            chainagePosition: currentChainagePosition,
                            chainageDecimalPlaces,
                            rlDecimalPlaces,
                            gradeDecimalPlaces,
                            distanceUnits: currentDistanceUnits,
                            gradeDisplay: currentGradeDisplay,
                            gradeType: 'percent'
                        }
                    })
                });

                if (response.status === 401) {
                    localStorage.removeItem('authToken');
                    window.location.href = '/';
                    return;
                }

                const data = await response.json();

                if (data.success) {
                    if (format === 'svg') {
                        // SVG text file download
                        const blob = new Blob([data.content], { type: 'image/svg+xml' });
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `ramp_${type}.svg`;
                        document.body.appendChild(a);
                        a.click();
                        window.URL.revokeObjectURL(url);
                        document.body.removeChild(a);
                    } else if (format === 'autocad' || format === 'dwf') {
                        // Text file download
                        const blob = new Blob([data.content], { type: 'text/plain' });
                        const url = window.URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `ramp_${type}.${format === 'autocad' ? 'scr' : format}`;
                        document.body.appendChild(a);
                        a.click();
                        window.URL.revokeObjectURL(url);
                        document.body.removeChild(a);
                    }
                } else {
                    throw new Error(data.error || 'Export failed');
                }

            } catch (error) {
                console.error('Export error:', error);
                alert('Export error: ' + error.message);
            } finally {
                // Restore button state
                button.disabled = false;
                button.classList.remove('loading');
                button.textContent = originalText;
            }
        }
    </script>
</body>
</html>